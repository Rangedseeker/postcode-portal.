
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Postcode Portal</title>
  <style>
    :root{
      --bg:#0b1220; --card:#121a2b; --muted:#a8b3cf; --text:#e8eeff; --accent:#60a5fa;
      --ok:#22c55e; --warn:#f59e0b; --err:#ef4444; --line:#22314f; 
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:20px;display:grid;gap:16px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:14px}
    h1{font-size:20px;margin:0 0 8px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:#0e1729;color:var(--text);outline:none}
    input:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(96,165,250,.25)}
    .pill{display:inline-grid;grid-auto-flow:column;gap:8px;align-items:center;padding:8px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted)}
    .muted{color:var(--muted)}
    .grid{display:grid;gap:10px}
    .topbar{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .topmatch{display:grid;gap:8px}
    .topmatch table{width:100%;border-collapse:collapse}
    .topmatch td{border-top:1px solid var(--line);padding:8px 0}
    .kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .kpi .card{padding:16px}
    .kpi h3{margin:0 0 8px;font-size:12px;color:var(--muted);font-weight:600}
    .kpi .val{font-size:22px}
    .small{font-size:12px}
    .sticky-dup{position:sticky;top:0;background:linear-gradient(#0b1220, #0b1220ee);z-index:10;padding-top:8px;padding-bottom:6px;border-bottom:1px solid var(--line)}
    @media (max-width:840px){
      .row,.topbar,.kpi{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- PRIMARY TOP SECTION -->
    <div class="card grid" id="primaryTop">
      <h1>Lookup</h1>
      <div class="topbar">
        <div>
          <label for="countrySearch">Country (UK / BEL / NL / LUX)</label>
          <input id="countrySearch" list="countryList" placeholder="Type UK, BEL, NL, or LUX and press Enter" autocomplete="off" />
          <datalist id="countryList"></datalist>
        </div>
        <div>
          <label for="postcodeSearch">Postcode</label>
          <input id="postcodeSearch" placeholder="Start typing a postcode and press Enter" autocomplete="off" disabled />
        </div>
      </div>

      <div class="topmatch card">
        <div class="pill"><span>Top matching row</span><span id="matchCount" class="muted"></span></div>
        <div id="topMatchPrimary">
          <div class="muted small">No match yet — start typing a postcode</div>
        </div>
      </div>
    </div>

    <!-- DUPLICATED TOP SECTION ABOVE NUMBERS -->
    <div class="sticky-dup">
      <div class="row">
        <div class="card">
          <strong class="muted small">Country / Postcode</strong><br/>
          <span id="dupCountry" class="pill">—</span>
          <span id="dupPostcode" class="pill">—</span>
        </div>
        <div class="card" id="topMatchSecondary">
          <strong class="muted small">Top matching row</strong>
          <div class="muted small">—</div>
        </div>
      </div>
    </div>

    <!-- NUMBERS / KPIs (your existing area; keep as-is if you have one) -->
    <div class="kpi">
      <div class="card"><h3>Total records (loaded)</h3><div class="val" id="statTotal">0</div></div>
      <div class="card"><h3>Country</h3><div class="val" id="statCountry">—</div></div>
      <div class="card"><h3>Postcode committed</h3><div class="val" id="statPostcode">—</div></div>
      <div class="card"><h3>Search hits (current)</h3><div class="val" id="statHits">0</div></div>
    </div>

    <!-- You can keep your table/results section below if you like. -->
  </div>


<script>
/** ===== Country aliases (names and codes) ===== **/
const DATA_FILES = {
  UK:  { label: 'United Kingdom', file: 'postcodes_uk.json'  },
  BEL: { label: 'Belgium',        file: 'postcodes_bel.json' },
  NL:  { label: 'Holland',        file: 'postcodes_nl.json'  },
  LUX: { label: 'Luxembourg',     file: 'postcodes_lux.json' }
};

// Accept both codes and names (case-insensitive)
const COUNTRY_ALIASES = new Map([
  ['UK', 'UK'], ['UNITED KINGDOM', 'UK'],
  ['BEL', 'BEL'], ['BELGIUM', 'BEL'],
  ['NL', 'NL'], ['NETHERLANDS', 'NL'], ['HOLLAND', 'NL'],
  ['LUX', 'LUX'], ['LUXEMBOURG', 'LUX']
]);

// If you already populate the datalist, you can keep it.
// (Optional) Update its labels to show names + codes:
const countryList = document.getElementById('countryList');
if (countryList) {
  countryList.innerHTML = '';
  Object.entries(DATA_FILES).forEach(([code, v]) => {
    const opt = document.createElement('option');
    opt.value = code;
    opt.label = `${code} – ${v.label}`;
    countryList.appendChild(opt);
  });
}

/** ===== State ===== **/
let selectedCountry = null;   // 'UK' | 'BEL' | 'NL' | 'LUX'
let dataRows = [];            // current country rows
let currentHits = [];
let committedPostcode = null;

/** ===== Helpers ===== **/
function normalizeRow(r){
  const postcode = (r.postcode ?? r.Postcode ?? r.code ?? r.pc ?? '').toString().trim();
  const region   = (r.region   ?? r.Region   ?? r['Town/Area'] ?? r.Town ?? r.Area ?? '').toString().trim();
  return { postcode, region };
}

function renderTopMatch(targetEl, row){
  if(!targetEl) return;
  targetEl.innerHTML = row ? `
    <table>
      <tr><td class="muted small">Postcode</td><td><strong>${row.postcode}</strong></td></tr>
      <tr><td class="muted small">Town / Area</td><td>${row.region || '—'}</td></tr>
    </table>` : `<div class="muted small">No match</div>`;
}

function score(row, q){
  const p = row.postcode.toLowerCase();
  if (p === q) return 0;
  if (p.startsWith(q)) return 1;
  if (p.includes(q)) return 2;
  return 9;
}

function filterPostcodes(q){
  if(!q){ currentHits = []; return; }
  const qq = q.trim().toLowerCase();
  currentHits = dataRows
    .filter(r => r.postcode && r.postcode.toLowerCase().includes(qq))
    .sort((a,b)=> score(a,qq) - score(b,qq) || a.postcode.localeCompare(b.postcode))
    .slice(0, 100);
}

/** ===== Loader ===== **/
async function loadCountry(code){
  const item = DATA_FILES[code.toUpperCase()];
  if(!item) return;

  // Reset state so postcode search always points at the selected country
  selectedCountry = code.toUpperCase();
  dataRows = [];
  currentHits = [];
  committedPostcode = null;

  // Reset UI pieces tied to postcode
  const postcodeSearch  = document.getElementById('postcodeSearch');
  const topMatchPrimary = document.getElementById('topMatchPrimary');
  const topMatchSecondary = document.getElementById('topMatchSecondary');
  const statTotal = document.getElementById('statTotal');
  const statCountry = document.getElementById('statCountry');
  const statPostcode = document.getElementById('statPostcode');
  const statHits = document.getElementById('statHits');
  const dupCountry = document.getElementById('dupCountry');
  const dupPostcode = document.getElementById('dupPostcode');

  renderTopMatch(topMatchPrimary, null);
  renderTopMatch(topMatchSecondary, null);

  if (postcodeSearch){
    postcodeSearch.value = '';
    postcodeSearch.disabled = true;
  }

  // Load dataset for this country
  try {
    const res = await fetch(item.file, { cache: 'no-store' });
    const raw = await res.json();
    const arr = Array.isArray(raw) ? raw : (raw.data || raw.rows || []);
    dataRows = arr.map(normalizeRow).filter(r => r.postcode);
    if (postcodeSearch) postcodeSearch.disabled = false;
  } catch (err) {
    console.error('Failed to load data for', selectedCountry, err);
  }

  // Update stats / badges
  if (statTotal)    statTotal.textContent   = dataRows.length.toLocaleString();
  if (statCountry)  statCountry.textContent = selectedCountry;
  if (statPostcode) statPostcode.textContent= '—';
  if (statHits)     statHits.textContent    = '0';
  if (dupCountry)   dupCountry.textContent  = selectedCountry;
  if (dupPostcode)  dupPostcode.textContent = '—';

  // Reflect chosen country into the input (normalized code)
  const countrySearch = document.getElementById('countrySearch');
  if (countrySearch) countrySearch.value = selectedCountry;
}

/** ===== Commit country on Enter OR blur ===== **/
function commitCountry(rawInput){
  if(!rawInput) return;
  const key = rawInput.trim().toUpperCase();
  const code = COUNTRY_ALIASES.get(key)
            || Object.keys(DATA_FILES).find(k => k.startsWith(key));
  if (code) loadCountry(code);
}

// Hook up events (keep if you already have similar listeners)
const countrySearch = document.getElementById('countrySearch');
if (countrySearch){
  countrySearch.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter') { e.preventDefault(); commitCountry(countrySearch.value); }
  });
  countrySearch.addEventListener('blur', ()=>{
    // Also commit when the user leaves the field
    commitCountry(countrySearch.value);
  });
}

// Postcode events (country-dependent filter)
const postcodeSearch = document.getElementById('postcodeSearch');
const matchCount = document.getElementById('matchCount');
const topMatchPrimary = document.getElementById('topMatchPrimary');
const topMatchSecondary = document.getElementById('topMatchSecondary');
if (postcodeSearch){
  postcodeSearch.addEventListener('input', ()=>{
    const q = (postcodeSearch.value || '').trim();
    filterPostcodes(q);
    if (matchCount) matchCount.textContent = currentHits.length ? `(${currentHits.length} hits)` : '';
    const first = currentHits[0] || null;
    renderTopMatch(topMatchPrimary, first);
    renderTopMatch(topMatchSecondary, first);
  });
  postcodeSearch.addEventListener('keydown', (e)=>{
    if(e.key !== 'Enter') return;
    const typed = (postcodeSearch.value || '').trim();
    if(!typed) return;
    let chosen = dataRows.find(r => r.postcode.toLowerCase() === typed.toLowerCase());
    if(!chosen){ filterPostcodes(typed); chosen = currentHits[0]; }
    if(chosen){
      e.preventDefault();
      committedPostcode = chosen.postcode;
      postcodeSearch.value = committedPostcode;
      renderTopMatch(topMatchPrimary, chosen);
      renderTopMatch(topMatchSecondary, chosen);
      const statPostcode = document.getElementById('statPostcode');
      const dupPostcode = document.getElementById('dupPostcode');
           if (statPostcode) statPostcode.textContent = committedPostcode;
      if (dupPostcode)  dupPostcode.textContent  = committedPostcode;
    }
  });
}

// Default on first load (optional)


</script>
</body>
</
